<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>无情剑客户端技术文档</title>
<link rel="stylesheet" type="text/css" href="../css/artical.css">
</head>
<body>
	
	<div class="title">
		无情剑客户端技术文档
	</div>
	<div class="content" style="width:700px">
	
											------- Tiger 完成于2011年5月30日 <br><br>

1，动画原理<br>
动画即运动的画面，一系列的画面依次出现就是动画，这其中的每一个画面是为一帧。
帧可以是一张图片，也可以是几个图片所拼成，这里的图片叫做帧的切片。切片拼成一个帧，几个帧组成一个动画。每个角色当前都须有一个动画，显示出一个角色其实就是在屏幕上画出该角色当前的动画。画一个动画就是画出它当前的帧，画帧则需要遍历画出帧所包含的所有切片。<br><br>

需要注意的是：无情剑里的fragment其意义并不是切片，而且一些切片的集合！这些切片都是使用的同一个源图片，该源图片上的某块位置才是真正的切片！一个fragment对应的是一个源图片，同时也对应了起源于该源图片的所有切片。画切片的时候其实是画该源图片上的对应区域！<br><br>

精灵sprite用来存储一些动画。并且同时存储了这些动画所需要的所有的帧，以及所有的帧所需要的所有的切片。现在的无情剑游戏中有几类sprite ：1，用于玩家在地图上的，包括了玩家站立动画和行走动画，构造自a_p_number.s文件。2，用于玩家在战斗中的，包括了战斗起手、逃跑、攻击等动画，构造自a_f_number.s文件。3，用于npc在地图上站立和行走的，构造自a_npc_number.s文件。4，用于npc在战斗中的, 构造自
a_f_npc_number.s文件。5，用于由坐骑的玩家在地图上站立和行走的，构造自a_ride_number文件。还有其他一些sprite，不做详述了。<br><br>
  
2，玩家形象和换装原理<br>
玩家的动画模板a_p_number和a_f_number 中的number是个变量，它对应的是各个武
器。换句话说，玩家的动画模板是由它当前使用的武器类型所决定的。所以在每次更换
武器后，如果武器类型发生了变化，则需要更换当前使用的动画模板。玩家形象决定于动画，动画决定于帧，而帧又决定于切片。所以玩家形象归根结底是决定于fragment.其实每个fragment对应的就是一个部位！玩家每个部位使用哪个fragment的信息是保存在玩家属性icon里面。在游戏初始化一个玩家的时候，会先根据玩家使用精灵的name来加载对应的动画模板，再根据玩家的icon来获得各个部位所需要的fragment，用这些fragment来替换掉模板中默认的那些fragment，就形成了玩家的形象。<br><br>

理解了上面玩家形象的实现原理，再理解换装就简单了。当实现装备动作时，如果新的装备和旧装备的形象不同，即对应的fragment不同，则用新装备对应的fragment替换掉原来的fragment序列里同部位的frgment即可。并且需要同步更新玩家icon的值到服务器。<br><br>

多说一句：sprite里的fragment数组中的各个元素对应不同的部位，正常情况下不应该有两个相同部位的fragment存在。<br><br>

注：结合动画编辑器的使用来理解动画原理可能会比较容易。<br><br>


3，地图原理<br>
一个地图包含了几个层，把这些层按顺序一个个的画出来，就是地图。游戏中的UI显示也是这个原理。无情剑游戏中的地图层的类型有三种：贴片层、像素层、玩家层。地图编辑器中还有一个阻挡层，但它并不会画出来，只是用于标示地图中的阻挡区域，这里不对其做讨论。贴片层一般在地图的最底层，是一个个小方块图片所拼成的，该层中会包含各个贴片坐标处的贴片信息，画贴片层时从上到下从左到右的遍历画出所有的贴片。像素层中包含了一些图片，以及这些图片应该画在哪个像素坐标处、按什么翻转方式画等信息，在画像素层的时候，只须遍历画出这些图片即是。因为这些图片所画的位置是像素坐标，所以称之为像素层。玩家层可以看做是像素层的特殊化子类，它也同样有要画出的像素图片，不同的是玩家层中要负责画出地图上的人物，比如玩家、NPC、怪物等等。玩家层同样是由上而下的画，它会按上下顺序画出像素图、玩家角色等。画的前后顺序将会形成遮挡。比如对一个玩家角色A来言，画在它前边的元素将可能会被A所遮挡，画在它后面的则有可能会遮挡住A。玩家层的这种特殊画法形成了地图中人物和景物、人物和人物等的互相遮挡。<br><br>


4，游戏小地图的实现<br>
小地图即地图的缩小化、简略化。对于当前地图显示部分的阻挡区域的各个位置，按比例算出其在小地图上的位置后，在地图上以阻挡色画出。非阻挡区域则用另外的颜色类似画出。这就是基本的小地图，可以看出大概的阻挡区域。再把地图上的玩家怪物等角色按比例画到小地图上相应位置。就形成了小地图。<br><br>

5，人物和队伍的行走<br>
客户端中玩家主角的行走control是本地生成本地执行的。每行走一定步数后，客户端会把玩家当前的最新位置坐标发到服务器，服务器会把该信息发给同地图的其他玩家。这些玩家的客户端会根据传下来的玩家id和其位置，通过自动寻路，使本机上的id对应玩家角色移动到目的位置。 注：如果玩家主角是在队伍中的跟随队员，则不需要这么做，因为同地图别的玩家并不需要知道某个跟随队员的运动情况，只须要知道其队长的运动情况，就会在本机上执行该队的运动。详细代码见mainCanvas类的syncMoveTo方法。该方法中即过滤掉了那些队伍的跟随队员。<br><br>

跟随行走的客户端实现：无论是队员跟随队长还是战宠跟随玩家，都需要在牵引者移动后同时更新跟随者的位置。这里以队伍行走来说明原理。队伍中队员之连接如链条状，队首牵动行走，一个牵着下一个，在像素级行走时，队伍中的各前后成员间会有一定距离，即相隔几个像素。每个玩家都有一个数组lastMoves[][]来记录他前几次的移动情况，在队伍行进时，后面的队员按他前面队员的lastMoves情况来更新自己的位置。人物每行动一次后都要将最新的走动情况压入到lastMoves数组中。战宠的跟随和队伍一样。<br><br>

附注：lastMoves是个二维数组，其一维是步数，二维是坐标或位移大小。一维大小为要记录的步数，实际等于前后两个队员的身位间隔像素+1。二维大小为2，对应横纵坐标。跟随行动的详情参看游戏中和otherplayer的lastMoves相关的代码！<br><br>



6，玩家跳地图<br>
	对于某地图来说，当有玩家或队伍跳入到该地图时，地图上的所有玩家将会收到jump in
	协议control。其执行结果会使得本地客户端的ActorList中添加入刚进来的玩家角色。
	当有玩家或队伍跳出该地图时，地图上所有玩家收到的则是jump out协议control。其
	执行同样会维护ActorList.。<br><br>

	对于跳地图的玩家和队伍，在跳地图时，他们的客户端会收到fullupdate 协议control.
该协议会使本地获得当前地图的其他玩家列表和npc列表。并同时有获得当前地图的怪物组信息，这些怪物组信息会被保存到Model的monsterGroup中，这是一个Hashtable
其key值是怪物组id，value值是怪物组。当前地图的每个怪物身上都有一个怪物组id. 
当玩家在地图上碰到怪物时，会根据怪物身上的怪物组id获得一组怪物，进而生成一个战场。<br><br>

7，任务接受和提交<br>
玩家在触碰到一个任务npc时，会先判断该npc身上的任务列表missions是否为空，如果为空则发control到服务器获得任务列表。接着会显示出npc任务列表里那些玩家没有做过并且没有接过并且满足接受条件的任务。同时也会显示出玩家已接的那些是提交给该npc的任务。玩家可以从这个显示出的列表中接受任务或提交已完成的任务。<br><br>

任务的接受条件和完成条件都被封转在类Condition中。任务是否满足接受条件和完成条件的判定方法分别是Mission的isCanAccept()和isComplete().<br><br>

玩家完成过哪些任务的信息保存在player类的missionStatus中，这是一个byte数组，
判断玩家是否完成过某个任务，只须看此任务的id对应在missionStatus中对应的位是否不为0。这个判定方法是Model类的isMissionFinish(missionId) .以面向对象的思想来看这个方法应放在player类中。<br><br>

地图中和任务有联系的npc头顶都会有个任务状态图标，如感叹号、问号等。不同颜色的不同图标具有不同的含义，比如黄色感叹号表示有任务可接，灰色问号表示交给它的任务还未完成。等等。 Npc是如何更新自己当前的任务状态图标的呢？ 这个是由服务器所控制的，当玩家的某些行为影响到自身所携带任务的完成情况或者地图上npc的任务列表中某些任务的可否接受情况时，服务器会下发npc任务状态改变的control.客户端据此修改npc的任务状态图标。<br><br>

8，UI显示原理<br>
UI的显示和地图的显示有相似之处，都是一层层的画出来的。当需要显示某个界面时，只须把该界面的对象压入到MainCanvas的layerStack中即可。layerStack是一个集合，其中包含了当前要显示在屏幕上的layer。游戏中会实时的画出它所包含的界面。
画的时候会从layerStack中最上边的一个全屏layer画起，遍历画出其上面的所有层。之所以从全屏层开始画是因为在其下方的层画也是白画，因为会被后面的全屏层所完全遮挡住。当不需要显示某个层时，只须将其从layerStack中删除即可。当layerStack不为空，即当前有显示出ui界面时，游戏的按键和点击等事件是交给最上面显示的UI层来处理的！<br><br>
9，UI实现详解<br>
	这里介绍一下无情剑项目中UI组件的实现原理以及常用组件。
	所有的组件都是继承自component。container是容器类的基类，同样继承自component.
一个容器中可以包含很多个组件，在画容器的时候会遍历画出它所包含的所有组件。组件的坐标值是相对它的父容器坐标值的相对值，这点在容器的drawComponents方法中可以观察到。<br><br>

容器当前都有一个焦点组件，该组件一般会高亮显示，标示焦点当前在自己身上。按键事件和鼠标事件会控制焦点的移动。按上方向键会把焦点移动到当前焦点组件的前一个组件，下方向键则会移动到下一个组件，这种上下关系是由加入到容器的顺序决定的，这是默认按键移动焦点的处理，某些时候需要特殊处理，比如响应左右方向键，可以通过覆盖handleKey方法实现。鼠标事件下，会根据所点击的位置遍历组件列表，查询到点击的组件，将该组件设为当前的焦点组件。<br><br>

再详细讲下按方向键后焦点的移动：当按向上的方向键时，先观察当前的焦点组件，如果该组件内部的焦点已经在最顶行，则令该组件失去焦点，令它的上一个组件获得焦点，反之，调用该组件内部的处理焦点移动的方法handleKey。同理，按向下的方向键时，先看当前焦点组件的内部焦点是否已经在最底行，在最底行则将焦点移动到下一个组件，反之调用焦点组件的内部处理方法。这种处理方式支持了容器的嵌套以及一些有内部焦点的组件和容器或互相之间的嵌套。判断组件的内部焦点是否在最顶行和最底行的方法分别是isFocusFirstRow和isFocusLastRow。<br><br>

只有当组件是焦点组件并且它的所有父容器也是焦点组件时，该组件才画出焦点样式。
详见组件的isFocus方法。<br><br>

当按下确定键或者鼠标点击到焦点组件时，会调用该组件父容器的containerListener的相关处理方法。containerListener是容器事件的监听器，负责处理容器的关闭、组件被触发等等事件。一般的用户界面的container监听器设置为本身即可。组件的事件处理会交给它的父容器来处理，如果直接父容器有设置了容器事件监听器，则可以处理，如果没有则需要交给更高层的父容器来处理，详见组件的notifyAllParent方法。现在无情剑项目中，鼠标点击事件是这样处理的，但按确定键的处理则只是交由直接父容器处理，我感觉应和点击一样的处理为佳，即container的handlekey方法中针对确定键的处理代码改为调用最深层的焦点组件的notifyAllParent方法。<br><br>

可以发现无情剑项目中组件的事件的处理是由父容器来执行的。这点与j2se swing的处理不同，swing中针对每个组件的监听器可以是任何的类，当然该类要实现对应接口才行。这种不同是因为该项目中的UI组件主要目的是为了满足该项目的需求，在满足了需求的前提下越方便适用越好，如果像swing那些每个组件都实现一套特定事件特定监听器的话无疑会增加N倍的运算和内存消耗。Swing的处理要考虑通用重用可扩展等方面，所以事件和监听器的数量都非常多。举个例子：无情剑中某界面中某个按钮的监听器一般是该界面自身，它不能被用作其他界面中按钮的监听器。但swing中就可以，因为它们都实现了按钮事件的监听接口。这段只是个人浅见，随口一说，其中可能有我理解不正确的地方，权作参考即可。另：swing组件的数据和实现是分离的，无情剑项目则是集合在一个类里。<br><br>
	容器还有另一个监听器componentListener, 用来监听容器中组件之间的焦点的改变。当
发生焦点改变时，会回调该组件监听器的对应方法。<br><br>

侧重讲一下ObjectListComponent组件，它实现的是一个对象列表。该组件的components所包含的并不是组件，而是实现了ListRenderer接口的对象。比如要显示一组技能的信息列表，可以使技能类实现这个接口，然后把一组技能添加到一个对象列表组件中，即可完成需求功能。StringRenderer是一个ListRenderer的实现类，用于显示一组字符串，支持设置各元素格的对齐方式和宽度比例，在元素格中的内容宽度大过格宽时会自动滚动。目前项目中，使用StringRenderer可以达到显示任何对象信息的要求，比如要显示技能的某些信息，可以把这些信息封装到一个StringRenderer中即可，这使得要列表显示的对象不一定非要实现ListRenderer接口。从代码复用的角度看，物品技能帮派玩家等等模型都不宜再实现ListRenderer接口，因为每实现一次就可能要写一次支持滚动、对齐方式、宽度比例的代码；从类的内聚原则上考虑模型应尽量不与其它的接口相耦合。<br><br>

ObjectListComponent中的components是ListRenderVector类型的，其实直接用Vector即可。ListRenderVector没必要，应舍去。ObjectGridListComponent
网格组件的实现与ObjectListComponent相似，目前主要用它来将背包中的物品以矩阵的形式显示出来，注意其中的数据组织方式是一维数组，使用时直接传递玩家的背包数组即可，这样使得玩家背包和网格组件引用同一个物品数组，保证了玩家背包中物品发生变化时，界面上的网格组件自动变化，而不需要写另外的代码来执行刷新。<br><br>

TabbedFrame提供一个选项卡容器，可以放入几个界面对象，通过选项卡来切换显示不同的界面。选项卡的名字是对应界面对象的标题。当前焦点在第几个选项卡上，则选项卡容器的界面显示区域就画出第几个界面。TabbedFrame中对按键事件和鼠标事件的焦点移动的响应与普通Container不同，详见其内部handleKey方法以及鼠标事件弹起的方法。<br><br>

前面有讲过，组件内部的x,y坐标值并不是它在屏幕上位置的绝对坐标值，而是相对于它的父容器位置的坐标值。在判断组件是否被鼠标击中的方法中，所接收到的鼠标击中位置是屏幕绝对坐标，所以也要用组件的屏幕绝对坐标来判断。获得组件的屏幕绝对位置的方法是组件的getAbsX和getAbsY两个方法。判断组件是否被鼠标击中的方法是组件的isPointerInView方法。<br><br>

无情剑项目中的鼠标事件有三种，分别是按下、拖动、弹起。某些情况下拖动以后不要求处理随之而来的弹起事件，这需要在弹起事件的处理方法中判断下刚才是否有经过拖动处理。 又某些情况下的拖动事件实际是由于手按下时的抖动所造成的，这种拖动不需要处理，处理这种情况的一种思路是在拖动事件的处理方法中判断下拖动距离，如果距离很小，就认为是抖动造成的，不予处理。这两种情况都有在对象列表组件中处理。<br><br>

在写一个组件的时候，应该尽可能的考虑其通用性，使得它可以被用在不同的地方。个人感觉有以下一些原则，仅供参考：尽量不和业务相关的类耦合；在某些组件的属性上要避免写死，一些属性应该由外部的使用者以参数的形式传入到其构造方法中，而不是直接写死在内部。尽量的采用抽象类或接口的引用。<br><br>
	
10，保护锁<br>
保护锁功能用来保护玩家的金钱和物品等不会丢失。当针对某个账号开通了保护锁功能，并且当前该功能为开启状态，当玩家执行某些动作时，服务器会判断该动作是否需要保护，如果需要就返回指令使客户端进入解锁界面，玩家需要输入保护锁的密码才能完成该动作。一般和金钱相关的操作服务器就会进行保护。<br><br>

客户端现在只有在商店中买东西时，会检测是否有开启保护锁，有的话就转到解锁界面进行保护，之所以商店买东西由客户端触发保护是因为商店中买东西是客户端直接先买到背包里然后才发送协议到服务器的！<br><br>

保护锁的密码现在是保存到本地的，在登陆游戏时会从RMS中读取出来，赋值到Model中的protectPassword。在保存到本地和读取到游戏中时，要注意的是保护锁密码是和账户名所挂钩的！保存到本地时，如果当前所用的账户名和之前从RMS中读取出的账户名不同，则需要把保存的保护锁密码设置为空！玩家在进入到游戏里后，在要进入保护锁菜单时需要解锁，通过解锁来给Model的protectPassword赋值，并保存到本地rms中。这里的逻辑稍有复杂，叙述不甚准确，详情见项目源码。<br><br>

11，背包物品的过滤<br>
某些时候需要过滤掉背包中的某些物品，使其不显示，或者盖灰。现在项目里都是盖灰处理的。自制、镶嵌、抽取等功能都有用到背包过滤。当需要过滤时，遍历背包把要过滤掉的物品的visible设为false即可。Model的filterBagItem方法用来过滤掉除指定类型以外的物品。showAllItem方法用来使背包中所有物品重新显示，当某个需要过滤功能的界面在退出时，一般都需要调用showAllItem使刚才被盖灰的物品重新显示出来。盖灰的处理详见ItemInfo类的render方法。<br><br>

12，宝石镶嵌<br>
该界面负责把宝石镶嵌到装备上。装备初次镶嵌时可以镶嵌所有类型的宝石，一旦镶嵌过，则以后镶嵌时必须是同类型的宝石。宝石类型对应的是buffer类型。镶嵌成功率会随着镶嵌次数的增加而降低。每个装备最多可以镶嵌20次。<br><br>

进入宝石镶嵌的界面有两种途径。一是通过装备界面或背包界面中选择一个装备点击后从出现的操作菜单中进入，此时显示的镶嵌界面会显示出这个待镶嵌的装备，背包栏会过滤出可供用来镶嵌的宝石；第二种进入镶嵌界面的途径是通过主菜单—装备—镶嵌进入，此时显示的镶嵌界面还没有待镶嵌的装备，背包中会过滤出所有装备，选择一个装备后即进入镶嵌的第二阶段---选宝石。点击宝石后出现的操作菜单里可以执行镶嵌。<br><br>

当需要更换待镶嵌的装备时，可以点击显示装备名的按钮，在弹出的操作菜单中执行重新选择，即可回到没有选择装备的阶段。<br><br>

另注：现在项目代码中有实现镶嵌设置保险线的功能，暂时是注释掉的。如果以后要开启该功能，只须放开注释即可。<br><br>



13，自制系统<br>
背包中的黄色装备可以参与自制，选择一个黄色装备(必需)、一到四个水晶(最少一个)、一个特殊合成材料(非必需) 就可以合成出来一个新的装备，此所谓自制。<br><br>

不同类型的装备要求的水晶类型不同。自制的第一步是先选择合成需要的黄色装备。第二步是选择水晶或特殊合成材料。进自制界面的途径也是两种，这点和镶嵌系统类似。<br><br>
如果是从背包中黄色装备进入自制界面，直接就到了自制的第二步，背包中会过滤出满足合成要求的水晶和特殊材料；如果是从主菜单—装备—自制 菜单进入的自制界面，由于尚未选择黄色装备，则需要执行自制的第一步---选装备，背包栏中会过滤出所有可用来自制的黄色装备。<br><br>

每执行一次选择材料的动作后，背包栏都会做一次过滤，以便显示出当前可以供选择的物品。可以点击放自制材料的六个按钮来对已选材料执行解除，解除操作后同样有背包栏的过滤动作。需要注意的是：由于水晶和特殊材料是和黄色装备相关联的，所以如果解除的是黄色装备，则需要同时解除掉所有水晶和特殊材料。<br><br>

注：执行过滤的方法filterBagItem会返回背包中第一个可选物品的位置，通过该位置可以判断当前是否还有可选物品，如果没有，可以给出提示；如果当前有可选物品，可以令背包栏把焦点移动到第一个可选物品。这两个功能均有实现过，现在已注释。需要时放开注释即可。<br><br>

14，抽取属性<br>
	把装备中的buffer抽离到黑水晶中，得到对应的其他颜色的水晶。此所谓抽取属性。
	可以把抽取属性看做是自制的反向操作。抽取属性需要的是装备和黑水晶。<br><br>
	
进抽取属性的界面也是两种途径，这点与自制和镶嵌类似。抽取属性较特殊的是：在选择装备之前和之后，界面显示有很大的差别，选择装备前，界面显示的是背包栏；选择装备后，界面显示的是buffer列表框。这是通过组建的visible属性来控制实现的。
选择装备之前，使背包框visible为true，buffer列表框的visible为false. 选择装备以后则反之。具体见代码。<br><br>

在已选择装备的情况下，按右软键会回到重新选择装备的步骤。界面上会重新显示背包栏。继续按右软键，才会退出抽取属性的界面。<br><br>

抽取所需要的黑水晶数目 = 所要抽取的属性的数目。 抽取所需要的元宝数目则是通过方法getNeedGoldNum获得。这个价格是定义在Model的extractFee中的。客户端的需要花钱的功能，其花费价格都是通过服务器所下传的，详见control类中功能性收费的相关代码。<br><br>

注：关于抽取属性、自制、宝石镶嵌这几个功能，有一个需要特别注意的地方是：由于它们都用到了背包过滤物品的功能，所以在退出这些界面时，需要把背包中所有物品的
Visible都修改回true!<br><br>


15，人物加点界面<br>
该界面负责玩家的属性点和相性点的分配以及玩家信息的显示。界面主体是一个选项卡容器，其中包含了四个选项卡：属性、相性、详细、社会。属性和相性两个选项卡容器负责点数分配，容器右部有显示出物攻内攻等六个受点数影响的玩家属性(属性界面和相性界面所显示的属性略有不同)，在分配点数的时候，右边的这六个属性的值会随之变化，其颜色也会变化。详细选项卡容器下是和玩家武力相关的所有属性，这些属性都是受属性点和相性点影响的，所以当前两个选项卡中有进行点数分配时，这里的显示也要发生变化。<br><br>

四个选项卡容器都是objectListPanel，每个panel中显示每一行的render类采用的是
StringRenderer, 因为该类可以支持列的宽度比例的设置、以及判断某点所点击的是哪一个列(这个对触屏加点减点的判断非常重要)。<br><br>

因为每加一个点或减一个点，界面都要变化显示出玩家最新的各个属性值，这就需要记录下当点数变化后玩家受影响的属性值大小。现在是通过一个玩家的克隆对象来实现的。playerInfo类中的player属性并不是玩家真正的自己，而只是一个复制品。所有的加点减点操作都直接针对这个player进行，界面上所显示的属性也是这个player的。会根据该player和玩家自己的属性的对比，对某些属性显示红色或绿色。<br><br>

addPoints是一个重要的数组，记录了加点情况。如果按的是左方向键，或者触屏点击到减号按钮所在的第二列，则调用left方法，修改addPoints数组中对应的值，刷新player的各项属性，接着刷新界面。特别注意要刷新详细选项卡界面。<br><br>

在确定分配点数时，根据addPoints构造一个分配control即可。分配玩后，需要刷新界面。因为此时玩家已经加点，各项属性已发生变化，所以player变量需要重新克隆。<br><br>

在initComponent方法中可以看到朝选项卡容器中添加详细选项卡界面时，有对选项卡容器的宽和高做了重新赋值，这是因为在TabbedFrame的添加方法中，会对所加容器的
宽高初始化，因为详细和社会两个选项卡容器的高度比前两个小、高度比前两个大，所以需要执行这个动作。<br><br>

16，商店<br>
界面主要由物品网格组件和按钮组件组成，界面比较简单。因为商店中的物品可以购买后并不会消失，所以商店网格组件不需要做刷新，它只须显示出商店物品即可。背包组件由于直接与人物背包相关联，所以在背包中物品有变化后，界面会自动相应变化，而不须手动刷新。详见objectGridListComponent组件的实现。<br><br>

	需要注意的一点是：商店中买卖物品的逻辑，是客户端先执行买卖然后才通知服务器的。
	比如买一个物品，客户端在判断有足够金钱后会直接将该物品放入背包，然后才通知服
务器，如果服务器通过交易验证则罢，通不过的话则返回背包物品位置调整的control,
使客户端纠正这次失败的交易。这种处理办法可以使得在大多数情况下连贯买卖物品
时，客户端只须发出交易control即可，服务器如果通过验证的话不用再返回control.
从而减少网络数据的传输。<br><br>

17，摆摊<br>
	界面布局类似商店界面。摆摊界面不同于其他UI界面的一个显著特点是：游戏中其他
	UI界面都是用于玩家和系统之间的交互，而摆摊界面是用于玩家和玩家之间的交互，
即摆摊者和顾客之间。在创建一个摆摊界面时，首先需要清楚的是当前使用者是摆摊者
还是顾客。顾客的摆摊界面上没有开始摆摊和取消摆摊这两个按钮。<br><br>

在摆摊界面类PeddlePanel中，有两个很重要的静态变量。分别是goodsInfoVector和
shelfItemArray 。这两个变量用来保存摆摊的货架上的物品。前者是peddleGoodsInfo
的集合，封装了货架上物品的定价信息、出售数量、货架上位置、背包中位置等信息，
和服务器的信息交互都是通过goodsInfoVector来完成的。后者shelfItemArray是一个
ItemInfo数组，包含的是货架物品对象的数组，类似于玩家的背包数组，它是用来支持
界面显示的，因为货架显示组件和背包显示组件都是用的objectGridListComponent组
件，该组件需要这样一个ItemInfo数组来支持显示。<br><br>

先从顾客的角度看摆摊界面，当浏览一个摊位时，发送一个浏览摊位的control到服务
器，服务器会返回所浏览的摊位的货架物品，客户端根据这些货架物品构造出一个摆摊
界面呈现给该顾客玩家，玩家可以从摊位上买货品。<br><br>

	再来看摆摊者的摆摊界面，这个比顾客角度要复杂很多，涉及货品的定价上架、背包
	对应物品更新、界面关闭后再次显示、登陆后显示等等各个方面。点选背包中的某个物
品进行定价后，物品会显示到货架上，同时背包中的该物品的数量需要减去刚才上架
的数量，如果减去后的数量为0，需要将该格设为不可见。上架一个或多个物品后，就
可以执行开始摆摊。摆摊成功后会关闭掉当前的摆摊界面，货架上的物品信息会保存在
goodsInfoVector中，玩家会显示出摆摊动画。地图上的其他玩家会获知到这个摆摊的消
息。<br><br>

摊主在摆摊成功后将不能移动位置，不能执行背包物品相关的任何操作。当摊主要浏览
自身的摊位时，可以通过查看摊位再进到摆摊界面，摆摊界面会根据goodsInfoVector
中的物品信息初始化shelfItemArray，进而刷新货架组件，从而把摊位货品显示给玩家。
因为货架上的物品被其他玩家买去后，服务器下发的摆摊control会同步更新摊主货架
上的物品，注意是更新的goodsInfoVector，所以摊主浏览摊位时需要由goodsInfoVector
来刷新货架组件。<br><br>

当摊主结束摆摊时，需要把货架上的物品再加回到人物背包，执行该操作后，如果背包
中某格物品数目为0，说明该格物品已全部被卖掉，则把该格物品设为null。如果某格物品数目之前为0，在加上货架上对应物品数量后大于0，则需要把该格设为可见。<br><br>

摊主在退出游戏后，并未退出摆摊状态，在下次登录时仍将保持摆摊状态，服务器在其
登录时会下发摆摊control，将摊位信息封装到goodsInfoVector中，这一次的摆摊control
的执行与其他时候有一点不同，它需要根据这些货架物品更新玩家的背包，即从玩家
背包中减去货架物品的数目！ 其他时候不需要做这个操作，因为在摆摊上架过程中已经更新了背包物品数目。peddlePanel中静态变量isPeddleControlAtGameLogin用来支持
这个操作，详细可参见与它有关的代码。<br><br>
18，control的监听<br>
很多时候客户端在发出一个control后，需要对服务器的响应进行监听，当接收到服务器所返回的control后，执行某些操作，比如更新界面、显示提示信息等等。这个是通过NetworkListener接口实现的。当需要监听一个control时，给其安排一个序列号，将该序列号和一个NetworkListener的实现类相关联（通过Hashtable），在接到服务器所返回control后，查询其序列号，看有没有相关联的监听器，如果有，则调用监听器的处理方法。<br><br>

19，新手教程<br>
	主要有装备教程、加点教程、邮件教程、礼包教程等。每个教程的触发有其触发条件，
	比如获得了某几个装备时会触发装备教程、获得可加点数时触发加点教程等等。每个
	教程都只会触发一次，玩家经历过哪些教程的信息会保存在游戏设置数据里，游戏设置
	数据在玩家登陆时会从服务器获得。当满足某个教程的触发条件时，需要判断下玩家是
否已经做过该教程，如果没有做过，则进入教程引导。在教程结束后，需要更新玩家的
游戏设置数据，记录下玩家经历过了该教程。<br><br>

教程中会屏蔽掉一些玩家操作，比如不能移动焦点、不可关闭界面等等，这是通过对
组件或界面在教程时的特殊处理来支持实现的。教程中还涉及一些文字的闪烁，可以
参看Buttom和PowerString中draw相关方法中的闪烁实现原理。<br><br>

20，高速模式<br>
在游戏的登录界面上有一个高速模式的复选框，如果选中，则游戏中网络连接将使用socket连接，此所谓高速模式。不是所有的手机都能使用高速模式，因为高速模式需要
使用cmnet (GPRS连接互联网)，某些手机不支持这个接入点，也就不能使用高速模式，
如果这些手机在登陆界面选中了高速模式的复选框，则登陆游戏将会失败，在登陆时的loading画面会提示玩家如果超过一分钟不能登陆进游戏则退出取消高速模式再登陆。
如果玩家没有选高速模式，则登陆时的loading提示会是随机的系统提示，登陆时会提示玩家关于高速模式的信息。<br><br><br><br>






											











一些要注意的地方<br><br>

1，跟随宠物头顶的疲劳图标和加点图标<br>
当战宠疲劳度达到满额或者战宠有了可添加的属性点和相性点后，其头顶会出现对应的图标，触屏点击这些图标可以触发对应的逻辑。暂时对疲劳图标没有对应逻辑。点到加点图标后，会转到宠物的加点界面。需要注意的是：因为触屏按下事件会引发主角的移动，一旦按下，就会引发主角移动并带动宠物移动，宠物头顶的图标随之移动，于是图标的位置改变了。在接下来的触屏弹起事件中，要根据触屏点坐标来判断是否点击到了这个图标，这个判断逻辑将会返回false. 本来应该是true的。现在程序里针对这种情况的处理是在触屏移动时先判断下点击的是否这两个图标，如果是的话就不做移动。
还有一种解决办法就是在触屏按下事件发生时就检验所按处是否这两个图标并进行处理，但有个随之而来的问题就是比如按的是加点图标则会弹出人物加点界面，那么接下来的鼠标弹起事件就会被该界面捕捉到，产生界面效果。这个在用户看来会很奇怪，所以不采取这种处理方式。
另外要说的一点是，现在这两个图标的位置移动变化是放在playerlayer中的draw方法中实时赋值的，即使宠物站着不动，还是会不断执行图标的坐标赋值，该处理不可取。应放在宠物实际移动的逻辑后面。<br><br>







附录：关于动画编辑器：<br><br>

注：我这里写的很乱，只可以作为参考。<br><br>

1，切片区点加载按钮，选择一个图片，在这个图片上划出一些方块范围，即是最基本的切片块。点保存按钮，可以保存这些切片的信息到xml文件中。所得xml文件名与图片名相同。创建xml以保存切片信息的代码详见：FragmentHolder类的output方法 、Fragment类的output方法。
<br><br>
对切片xml文件中各个节点的说明：
 name_byteIDfragmentImgs_r0 ： 所用图片的名字。(图片在该xml的同目录下)
 avatarX 、avatarY ：用于切片换装时的位置调整
 id_byte_a0 ：切片id ，唯一的，确定一个切片。切片id的赋值参见FragmentHolder类的getNextFragmentId方法，可
见新切片的id是已有的所有切片的id的最大值加1。
 name_utf_a1 ：切片名字，= "name" + id ，其赋值参加Fragment的构造方法。
 index_shortIDfragments_n0 ： = 所用图片的名字 + "_" + id . 表示该切片在图片的所有切片中的索引
 x_uByte_r1 、y_uByte_r2 ： 切片在图片中的位置，即左上角坐标。	
 w_byte_r3 、h_byte_r4 ： 切片在图片中的大小，即宽度和高度。<br><br>


2，关于动画文件xml<br>
 菜单栏上选择文件，选择"打开xml" ，可以打开已有的动画xml文件。
 帧编辑区选择增加按钮，点击，选择已有的切片xml，可以将其中的切片图片都添加进来，然后实施拼接，组成一个frame。 
 菜单栏上选择文件，选择"保存xml" ，可以保存选择当前打开或编辑的动画信息，包括帧、动画、精灵等信息。
 这样就会生成一个动画的xml文件。代码详见：InOut类的outXML(Sprite sprite, File file)方法 、Sprite的output方法。 
  <br><br>
 该xml的文件名可以由自己输入，不过选择都是统一的以a_开头的。

（1）fragmentFile -----该精灵所需要的所有的切片文件       <br>
（2）id_byte_n0 ： 相当于索引。 InOut类的outXML(Sprite sprite, File file)方法执行赋值。
      file_byteIfragmentFiles_n1： 切片的xml文件的文件名<br><br>

 （3）frames_arr --- 帧信息
id_byte_a0 ： frame的id 。 构造方法中会给ID赋值。 同时，在生成精灵xml文件时，会给所有的frame的id按顺序赋
值。详见代码：FrameHolder的defragment方法。
	name_utf_a1 ："FRM_" + ID

    colisionX_byte_r1 、 colisionY_byte_r2 、 colisionX2_byte_r3、 colisionY2_byte_r4  --- 表示碰撞区域的左上和右下两个点的坐标。
<br><br>

（3）FrameFragment ---- FrameFragment即帧的切片块

 center_x 、 center_y : 中心点坐标。中心点在帧中的坐标。
 fragmentId_byte_n0 ： 所用到的fragment的id.
 fragmentsFileId_byte_n1 : fragmentFile的id.
 x_byte_r0 、y_byte_r1 ： 左上角点的坐标
 id_byte_a0 ： id，构造时赋值。似乎没啥意义。
 name_utf_a1 ： 用的是fragment的name
 index_shortIRfragments_r2 : 所用切片的源图片的名字 + 切片id
 transformType 、z_transformation_byte_r3 ：切片翻转规则。
 <br><br>
(4) animations_arr ----- 动画信息

 name_utf_a0 ： 名字， 动画名字是创建时自己输入的。 名字预示了动画是干什么的。 ---- 无情剑里的动画名字全是数字
。不同的数字表示是走路还是战斗起手等动画！！！！！
 type_byte_r0 ： 动画类型
 noLoops_byte_r1 ： 构造方法里只赋值为1。现在没啥用。 表示循环次数。
 endAnimAction_byte_r2 ： 似乎是只用于动画编辑器中的运行。
 xanimationId 、 还没看出作用
 xcheckId 、还没看出作用
 ymapData 、还没看出作用
<br><br>
（5） gesture ---- 动画的组成单元，封装了帧，含有帧的停留时间，位移情况 等信息
 name_utf_a0 ： 名字， = frame.getName() + "[" + frame.getID() + "]"
 length_short_r0 ：帧的延时长度，即显示几次。
 ischeck ： 好像是判定帧的是否。 
 ischeck ： frame 的 id
 speedX_short_r1 、speedY_short_r2 ：表示偏移情况。<br><br>








//=====================================================================<br>

SpriteParser工具 ------------ 负责把切片xml和精灵xml 解析成 .f 和 .s 文件<br>

先来看切片信息是如何封装为.f文件的：<br>
FragmentHander类来做这个事情。<br><br>

FragmentHander读取切片xml文件数据，将数据封装到Fragment 里面。
再通过Fragment的toBytes方法，把信息写到.f文件中。
这个.f的文件名是和切片xml的文件名一样的。<br><br>

接下来会把 源图片的数据 也写入到.f文件中。 详细见Run类的parseFragmentFile方法。<br><br>

关于动画xml文件 ： a_p_ 开头的是精灵行走、站立 的动画。 a_f_ 开头的是精灵战斗的动画。 a_ride_ 开头的是有
坐骑的精灵行走、站立的动画。 a_shop_1 是摆摊动画。<br><br>
















	
	
	
	
	<br>
		
	



	
		
	</div>
	
</body>
</html>